<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
    // concat, filter, map, slice, 스프레드(전개) 연산자

    console.log("1. ============== 스프레드 연산자");
    const a = [1,2,3];
    const bb = a; // 앝은 복사 -> 주소 저장

    // 가장 쉬운 방법 스프레드 -> 흩뿌리다 ...을 사용
    const b = [...a]; // b라는 공간을 새로 만들어서 a를 저장 [1,2,3]
    b.push(4) // push() 기존 배열에 값을 추가 하는 방법
    console.log(`a의 값 : ${a}`) // 1,2,3
    console.log(`b의 값 : ${b}`) // 1,2,3,4
    console.log(b);
   

    console.log("2. ============== 추가하기(새로운 배열을 만들면서)");
    const a2 = [1,2,3];
    const b2 = a2.concat(4); // b2에 4를 추가하면서 a2 값을 할당 -> 새로운 공간에 만듬
    //const t2 = a2.push(4); // -> 내가 넣은 4만 t2에 들어감
    console.log(`a2의 값 : ${a2}`) // 1,2,3
    console.log(`b2의 값 : ${b2}`) // 1,2,3,4

     // 응용하기
     const c2 = [0, ...a2, 4]; // 1,2,3,4 -> concat() 사용과 같음
     console.log(`c2의 값 : ${c2}`) // 1,2,3,4

    console.log("3. ============== 걸러내기"); // 주로 삭제할때 사용함
    const a3 = [1,2,3];
    //a3의 값이 하나씩 들어가서 함수가 진행됨 
    const b3 = a3.filter((n)=> { return n != 1;});  // filter특징 bool을 return을 받음
    // -> true 결과만 걸러내줌  -> 삭제할때 쓰기 ex) 특정 id 번호 골라서 삭제하기 
    console.log(b3); // 2, 3 
    
    console.log("4. ============== 잘라내기(중간에 삽입)"); // 중간에 삽입하기 
    // ex) 게시글 중간에 글 삽입
    const a4 = [1,2,3];
    const b4 = a4.slice(0,2) // start 수, end 수
    console.log(b4); // 2번 인덱스 전까지 -> [1,2]
    const c4 = [a4.slice(0,2)];
    console.log(c4); // [[1,2]]
    const d4 = [...a4.slice(0,2)]; // [1,2]
    console.log(d4);
    const f4 = [...a4.slice(0,2), 4, ...a4.slice(2,3)]; // [1,2,4,3]

    console.log("5. ============== 반복하기");
    const a5 = [1,2,3];
    // forEach() 콜백 function이 들어가야함 -> 익명 함수
    // a5에서 순회하는 데이터가 n에 들어감
    a5.forEach((n) => { console.log(n)}); // foreach는 리턴을 못함 -> 복사 x -> 뿌림 o
    //const b5 = a5.map((n) => { return n}); -> { return n } 생략 가능 -> 바로 리턴
    const b5 = a5.map((n) => n); // const b5 = [...a5]; -> 값 하나하나를 가공하는 게 가능
    console.log(b5); // 다른 레퍼런스임 
    const d5 = a5.map((i) => i+10);
    console.log(d5); // [11, 12, 13]

    const data = {name:"이걸로바꿔"};
    const a6 = { id:1, name:"홍길동"};
    const b6 = {...a6, name:"임꺽정"}; // 수정방법 -> 덮어 씌우면 됨 -> 새로운 배열
    console.log(a6);
    console.log(b6);
    const c6 = {...a6, ...data}; // data를 흩뿌리기하면 덮어씌움 -> 새로운 배열
    // ▲ 데이터가 한 건이라면 쉽게 수정이 가능
    
    const users = [
        {id:1, name:"테스터", phone:"1111"},
        {id:2, name:"이스터", phone:"2222"},
        {id:3, name:"삼스터", phone:"3333"},
    ];

    const updateUserDto = {
        id:2, name:"홍길동"
    };
// users[1].name = updateUserDto.name; 원래 값이 바뀜 -> 최적화 x 

// 필터 x -> 나머지 것들이 사라져버림 -> map()을 이용해서 일단 모두 출력 후 id가 2인것만

const newUsers = users.
map(u => u.id === updateUserDto.id ? {...u, ...updateUserDto} : u); // const newUser = {...users}
 // ▲ 데이터가 여러건 중 하나라면 특정 조건이 맞는다면 변경해주기
console.log("newUsers", newUsers);



</script>

</body>
</html>